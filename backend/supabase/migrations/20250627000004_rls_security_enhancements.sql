-- Migration: 20250627000004_rls_security_enhancements.sql
-- Description: Enhanced RLS policies with 2025 security best practices
-- Impact: Strengthens security policies and adds performance optimizations for PostgreSQL 17
-- Author: Claude Code (2025-06-27)

-- ============================================================================
-- Security Enhancement Policies (2025 Best Practices)
-- ============================================================================

-- Policy: Enhanced user profile security (prevent unauthorized auth_id access)
DROP POLICY IF EXISTS "Users can view others basic profile" ON users;
CREATE POLICY "Users can view others basic profile" ON users
FOR SELECT USING (
    auth.role() = 'authenticated' AND
    id != auth.uid()::uuid AND
    -- Only allow viewing specific profile fields, not sensitive data
    NOT (profile ? 'private_data' OR profile ? 'internal_notes')
);

-- Policy: Prevent unauthorized profile updates
CREATE POLICY "Prevent unauthorized profile updates" ON users
FOR UPDATE USING (auth.uid()::text = auth_id)
WITH CHECK (
    auth.uid()::text = auth_id AND
    -- Prevent updating critical fields
    NEW.auth_id = OLD.auth_id AND
    NEW.email = OLD.email AND
    NEW.created_at = OLD.created_at
);

-- ============================================================================
-- Enhanced Case Management Policies
-- ============================================================================

-- Policy: Prevent case data leakage through metadata
CREATE POLICY "Secure case metadata access" ON cases
FOR SELECT USING (
    user_id = auth.uid()::uuid AND
    deleted_at IS NULL AND
    -- Prevent access to cases marked as sensitive
    NOT (metadata->>'is_sensitive' = 'true' AND auth.role() != 'service_role')
);

-- Policy: Rate limiting for case creation (prevent spam)
CREATE POLICY "Case creation rate limit" ON cases
FOR INSERT WITH CHECK (
    auth.uid()::uuid IS NOT NULL AND
    -- Limit to 100 cases per user (can be adjusted)
    (
        SELECT COUNT(*) 
        FROM cases 
        WHERE user_id = auth.uid()::uuid AND deleted_at IS NULL
    ) < 100
);

-- ============================================================================
-- Enhanced Conversation Security
-- ============================================================================

-- Policy: Secure conversation message access
DROP POLICY IF EXISTS "Users can manage messages through conversation logs" ON conversation_messages;
CREATE POLICY "Users can manage messages through conversation logs" ON conversation_messages
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM conversation_logs cl
        JOIN cases c ON c.id = cl.case_id
        WHERE cl.id = conversation_log_id
        AND c.user_id = auth.uid()::uuid 
        AND c.deleted_at IS NULL
        -- Additional security check for message sensitivity
        AND NOT (metadata->>'is_sensitive' = 'true' AND auth.role() != 'service_role')
    )
);

-- Policy: Prevent message tampering
CREATE POLICY "Prevent message content tampering" ON conversation_messages
FOR UPDATE USING (
    EXISTS (
        SELECT 1 FROM conversation_logs cl
        JOIN cases c ON c.id = cl.case_id
        WHERE cl.id = conversation_log_id
        AND c.user_id = auth.uid()::uuid 
        AND c.deleted_at IS NULL
    )
)
WITH CHECK (
    -- Prevent changing message content and speaker after creation
    NEW.content = OLD.content AND
    NEW.speaker = OLD.speaker AND
    NEW.message_timestamp = OLD.message_timestamp
);

-- ============================================================================
-- Enhanced Reply Generation Security
-- ============================================================================

-- Policy: Secure generated replies with usage tracking
DROP POLICY IF EXISTS "Users can manage generated replies through cases" ON generated_replies;
CREATE POLICY "Users can manage generated replies through cases" ON generated_replies
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM cases c
        WHERE c.id = case_id
        AND c.user_id = auth.uid()::uuid 
        AND c.deleted_at IS NULL
    )
    AND
    -- Prevent access to replies generated by different users
    EXISTS (
        SELECT 1 FROM usage_logs ul
        WHERE ul.user_id = auth.uid()::uuid
        AND ul.usage_type = 'reply_generation'
        AND ul.metadata->>'generated_reply_id' = id::text
    )
);

-- Policy: Prevent reply suggestion manipulation
CREATE POLICY "Prevent reply suggestion manipulation" ON reply_suggestions
FOR UPDATE USING (
    EXISTS (
        SELECT 1 FROM generated_replies gr
        JOIN cases c ON c.id = gr.case_id
        WHERE gr.id = generated_reply_id
        AND c.user_id = auth.uid()::uuid 
        AND c.deleted_at IS NULL
    )
)
WITH CHECK (
    -- Only allow updating tracking fields, not suggestion content
    NEW.suggestion = OLD.suggestion AND
    NEW.category = OLD.category AND
    NEW.generated_reply_id = OLD.generated_reply_id
);

-- ============================================================================
-- Enhanced Subscription Security
-- ============================================================================

-- Policy: Prevent subscription tampering
CREATE POLICY "Prevent subscription tampering" ON user_subscriptions
FOR UPDATE USING (false); -- Only service_role can update subscriptions

-- Policy: Secure subscription viewing
DROP POLICY IF EXISTS "Users can view own subscriptions" ON user_subscriptions;
CREATE POLICY "Users can view own subscriptions" ON user_subscriptions
FOR SELECT USING (
    user_id = auth.uid()::uuid AND
    -- Hide sensitive stripe data from regular users
    auth.role() = 'service_role' OR stripe_subscription_id IS NOT NULL
);

-- ============================================================================
-- Enhanced Usage Tracking Security
-- ============================================================================

-- Policy: Prevent usage log tampering
CREATE POLICY "Prevent usage log tampering" ON usage_logs
FOR UPDATE USING (false); -- Usage logs are immutable

CREATE POLICY "Prevent usage log deletion" ON usage_logs
FOR DELETE USING (false); -- Usage logs cannot be deleted

-- Policy: Secure usage log insertion
CREATE POLICY "Secure usage log insertion" ON usage_logs
FOR INSERT WITH CHECK (
    user_id = auth.uid()::uuid AND
    -- Prevent backdating usage logs
    created_at >= (now() - interval '1 minute')
);

-- ============================================================================
-- Advanced Security Functions (2025 Best Practices)
-- ============================================================================

-- Function: Audit sensitive operations
CREATE OR REPLACE FUNCTION audit_sensitive_operation(
    operation_type varchar,
    table_name varchar,
    record_id uuid,
    details jsonb DEFAULT '{}'
)
RETURNS void AS $$
BEGIN
    -- Log sensitive operations for security monitoring
    INSERT INTO usage_logs (user_id, usage_type, metadata)
    VALUES (
        auth.uid()::uuid,
        'security_audit',
        jsonb_build_object(
            'operation', operation_type,
            'table', table_name,
            'record_id', record_id,
            'details', details,
            'ip_address', current_setting('request.headers', true)::jsonb->>'x-forwarded-for',
            'user_agent', current_setting('request.headers', true)::jsonb->>'user-agent'
        )
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Check if user has valid subscription for operation
CREATE OR REPLACE FUNCTION check_subscription_access(operation_type varchar)
RETURNS boolean AS $$
DECLARE
    user_plan record;
BEGIN
    SELECT sp.features INTO user_plan
    FROM user_subscriptions us
    JOIN subscription_plans sp ON sp.id = us.plan_id
    WHERE us.user_id = auth.uid()::uuid
    AND us.status IN ('active', 'trialing')
    ORDER BY us.created_at DESC
    LIMIT 1;
    
    IF NOT FOUND THEN
        -- Default free tier permissions
        RETURN operation_type IN ('basic_reply_generation', 'text_input');
    END IF;
    
    -- Check if operation is allowed for current plan
    RETURN (user_plan.features ? operation_type) OR 
           (user_plan.features->>'tier' = 'unlimited');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Triggers for Enhanced Security Monitoring
-- ============================================================================

-- Trigger: Audit sensitive case operations
CREATE OR REPLACE FUNCTION audit_case_operations()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' OR OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN
        PERFORM audit_sensitive_operation('case_deletion', 'cases', OLD.id, 
            jsonb_build_object('case_name', OLD.name, 'partner_name', OLD.partner_name));
    END IF;
    
    IF TG_OP = 'INSERT' THEN
        PERFORM audit_sensitive_operation('case_creation', 'cases', NEW.id,
            jsonb_build_object('case_name', NEW.name, 'partner_name', NEW.partner_name));
        RETURN NEW;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_case_operations_trigger
    AFTER INSERT OR UPDATE OR DELETE ON cases
    FOR EACH ROW EXECUTE FUNCTION audit_case_operations();

-- Trigger: Audit reply generation
CREATE OR REPLACE FUNCTION audit_reply_generation()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM audit_sensitive_operation('reply_generation', 'generated_replies', NEW.id,
            jsonb_build_object('model', NEW.llm_model, 'case_id', NEW.case_id));
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_reply_generation_trigger
    AFTER INSERT ON generated_replies
    FOR EACH ROW EXECUTE FUNCTION audit_reply_generation();

-- ============================================================================
-- Performance Optimizations for RLS (PostgreSQL 17)
-- ============================================================================

-- Optimize RLS policy evaluation with materialized views for complex joins
CREATE MATERIALIZED VIEW user_case_access AS
SELECT 
    c.id as case_id,
    c.user_id,
    c.deleted_at IS NULL as is_active
FROM cases c
WHERE c.deleted_at IS NULL;

-- Index for fast RLS lookups
CREATE UNIQUE INDEX idx_user_case_access_case_id ON user_case_access(case_id);
CREATE INDEX idx_user_case_access_user_id ON user_case_access(user_id);

-- Refresh materialized view automatically
CREATE OR REPLACE FUNCTION refresh_user_case_access()
RETURNS TRIGGER AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_case_access;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER refresh_user_case_access_trigger
    AFTER INSERT OR UPDATE OR DELETE ON cases
    FOR EACH STATEMENT EXECUTE FUNCTION refresh_user_case_access();

-- ============================================================================
-- Additional Security Constraints
-- ============================================================================

-- Ensure conversation messages belong to correct user's cases
ALTER TABLE conversation_messages ADD CONSTRAINT conversation_messages_user_isolation
CHECK (
    EXISTS (
        SELECT 1 FROM conversation_logs cl
        JOIN cases c ON c.id = cl.case_id
        WHERE cl.id = conversation_log_id
        AND c.user_id = auth.uid()::uuid
    )
) NOT VALID;

-- Gradually validate existing data
ALTER TABLE conversation_messages VALIDATE CONSTRAINT conversation_messages_user_isolation;

-- ============================================================================
-- Documentation and Comments
-- ============================================================================

COMMENT ON FUNCTION audit_sensitive_operation IS 'Logs sensitive operations for security monitoring and compliance';
COMMENT ON FUNCTION check_subscription_access IS 'Validates user subscription permissions for specific operations';
COMMENT ON MATERIALIZED VIEW user_case_access IS 'Optimized view for RLS policy evaluation, refreshed automatically';

-- ============================================================================
-- Grant Permissions for New Functions
-- ============================================================================

GRANT EXECUTE ON FUNCTION audit_sensitive_operation TO authenticated;
GRANT EXECUTE ON FUNCTION check_subscription_access TO authenticated;
GRANT EXECUTE ON FUNCTION audit_sensitive_operation TO service_role;
GRANT EXECUTE ON FUNCTION check_subscription_access TO service_role;

-- Grant permissions for materialized view
GRANT SELECT ON user_case_access TO authenticated;
GRANT SELECT ON user_case_access TO service_role;